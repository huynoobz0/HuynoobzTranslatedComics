<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Truyện do Huynoobz dịch</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
    body {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
    }
    
    #header-bar {
        background: #222;
        color: #fff;
        padding: 15px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: sticky;
        top: 0;
        z-index: 1000;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    #header-title {
        font-size: 20px;
        font-weight: bold;
        display: flex;
        flex-direction: column;
        gap: 4px;
    }
    
    #header-title-text {
        font-size: 20px;
        font-weight: bold;
    }
    
    #header-github-link {
        font-size: 12px;
        color: #aaa;
        text-decoration: none;
        transition: color 0.2s;
    }
    
    #header-github-link:hover {
        color: #fff;
        text-decoration: underline;
    }
    
    #header-buttons {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    
    #header-buttons button {
        background: #444;
        color: #fff;
        border: none;
        padding: 8px 15px;
        font-size: 14px;
        cursor: pointer;
        border-radius: 4px;
        transition: background 0.2s;
    }
    
    #header-buttons button:hover {
        background: #555;
    }
    
    #header-buttons button:disabled {
        display: none;
    }
    
    #width-controls {
        display: none;
        align-items: center;
        gap: 8px;
        margin-right: 10px;
    }
    
    #width-controls button {
        background: #444;
        color: #fff;
        border: none;
        padding: 5px 10px;
        font-size: 16px;
        cursor: pointer;
        border-radius: 4px;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    #width-controls button:hover {
        background: #555;
    }
    
    #width-display {
        color: #fff;
        font-size: 14px;
        min-width: 60px;
        text-align: center;
    }
    
    #content {
        min-height: calc(100vh - 60px);
    }
    
    #content.viewing-chapter {
        margin: 0 auto;
        padding: 20px;
        transition: max-width 0.3s ease;
    }
    
    #content.viewing-chapter > * {
        max-width: 100%;
        margin: 0 auto;
    }
</style>
</head>

<body>
<div id="header-bar">
    <div id="header-title">
        <div id="header-title-text">Truyện do Huynoobz dịch</div>
        <a id="header-github-link" href="https://github.com/huynoobz0/HuynoobzTranslatedComics" target="_blank" rel="noopener noreferrer">Vào đây nếu bị lỗi nhé!</a>
    </div>
    <div id="header-buttons">
        <div id="width-controls">
            <button id="width-decrease" title="Giảm độ rộng">−</button>
            <span id="width-display">800px</span>
            <button id="width-increase" title="Tăng độ rộng">+</button>
        </div>
        <button id="back-chaplist-btn" style="display:none;">Danh sách chap</button>
        <button id="back-home-btn" style="display:none;">Trang chủ</button>
    </div>
</div>
<div id="content">Đang tải...</div>

<script>
//load home.html
async function loadPage(page) {
    console.log("loadPage", page);
    // page = tên file không đuôi, VD: "home"
    const url = `https://raw.githubusercontent.com/huynoobz0/HuynoobzTranslatedComics/refs/heads/main/${page}.html`;
    
    try {
        const res = await fetch(url);
        if (!res.ok) {
            document.getElementById("content").innerText = "Lỗi tải dữ liệu";
            return;
        }
        const html = await res.text();
        document.getElementById("content").innerHTML = html;
        
        // Update button visibility
        const backHomeBtn = document.getElementById("back-home-btn");
        const backChapListBtn = document.getElementById("back-chaplist-btn");
        if (page === "home") {
            if (backHomeBtn) backHomeBtn.style.display = "none";
            if (backChapListBtn) backChapListBtn.style.display = "none";
            // Update latest chapters when home page loads
            setTimeout(() => {
                updateLatestChapters();
            }, 500);
        } else if (page === "chapList") {
            if (backHomeBtn) backHomeBtn.style.display = "inline-block";
            if (backChapListBtn) backChapListBtn.style.display = "none";
        }
    } catch (e) {
        document.getElementById("content").innerText = "Không thể kết nối tới GitHub";
    }
};

// Initialize page based on URL params
const params = new URLSearchParams(location.search);
const page = params.get("p") || "home";
loadPage(page).then(() => {
    // If loading chapList, also load chapters after page is ready
    if (page === "chapList") {
        const story = params.get("story");
        if (story) {
            setTimeout(() => {
                loadChapters(decodeURIComponent(story));
            }, 100);
        }
    } else if (page === "home") {
        // Update latest chapters when home page loads
        setTimeout(() => {
            updateLatestChapters();
        }, 500);
    }
});

//load chapList.html
async function openStory(storyName) {
    const encoded = encodeURIComponent(storyName);
    const backBtn = document.getElementById("back-home-btn");
    if (backBtn) backBtn.style.display = "block";
    
    // Wait for loadPage to complete before calling loadChapters
    await loadPage("chapList");
    
    // Small delay to ensure DOM is ready
    setTimeout(() => {
        loadChapters(storyName);
    }, 100);
};

// Numeric sorting function for filenames
function numericSort(a, b) {
    // Extract numbers from filename (e.g., "1.html" -> 1, "1.5.html" -> 1.5, "10.html" -> 10)
    const getNumericValue = (name) => {
        const match = name.match(/^(\d+\.?\d*)/);
        return match ? parseFloat(match[1]) : Infinity;
    };
    const numA = getNumericValue(a.name);
    const numB = getNumericValue(b.name);
    
    // If both have numbers, sort numerically
    if (numA !== Infinity && numB !== Infinity) {
        return numA - numB;
    }
    // If only one has a number, put it first
    if (numA !== Infinity) return -1;
    if (numB !== Infinity) return 1;
    // If neither has a number, sort alphabetically
    return a.name.localeCompare(b.name);
}

// Cache utility for GitHub API responses (1 hour expiration)
const CACHE_EXPIRY = 60 * 60 * 1000; // 1 hour in milliseconds

function getCachedData(key) {
    try {
        const cached = localStorage.getItem(`gh_cache_${key}`);
        if (!cached) return null;
        
        const { data, timestamp } = JSON.parse(cached);
        const now = Date.now();
        
        // Check if cache is still valid (within 1 hour)
        if (now - timestamp < CACHE_EXPIRY) {
            return data;
        } else {
            // Cache expired, remove it
            localStorage.removeItem(`gh_cache_${key}`);
            return null;
        }
    } catch (e) {
        console.error("Error reading cache:", e);
        return null;
    }
}

function setCachedData(key, data) {
    try {
        const cacheData = {
            data: data,
            timestamp: Date.now()
        };
        localStorage.setItem(`gh_cache_${key}`, JSON.stringify(cacheData));
    } catch (e) {
        console.error("Error writing cache:", e);
        // If storage is full, try to clear old cache entries
        try {
            const keys = Object.keys(localStorage);
            keys.filter(k => k.startsWith('gh_cache_')).forEach(k => localStorage.removeItem(k));
            localStorage.setItem(`gh_cache_${key}`, JSON.stringify(cacheData));
        } catch (e2) {
            console.error("Failed to clear cache:", e2);
        }
    }
}

// Cached fetch function for GitHub API
async function cachedFetch(apiUrl) {
    // Use URL as cache key
    const cacheKey = apiUrl;
    
    // Check cache first
    const cachedData = getCachedData(cacheKey);
    if (cachedData !== null) {
        console.log("Using cached data for:", apiUrl);
        return cachedData;
    }
    
    // Fetch from API
    console.log("Fetching from API:", apiUrl);
    const res = await fetch(apiUrl);
    
    if (!res.ok) {
        const errorText = await res.text();
        throw { status: res.status, message: errorText };
    }
    
    const data = await res.json();
    
    // Check if data is an error object from GitHub API
    if (data.message) {
        throw { status: res.status, message: data.message };
    }
    
    // Cache the response
    setCachedData(cacheKey, data);
    
    return data;
}

async function loadChapters(story) {
    console.log("loadChapters", story);
    
    // Get story from parameter or URL params
    if (!story) {
        const params = new URLSearchParams(location.search);
        story = params.get("story");
        if (story) {
            story = decodeURIComponent(story);
        }
    }

    const storyTitleEl = document.getElementById("story-title");
    const chapListEl = document.getElementById("chap-list");
    
    if (!story) {
        if (storyTitleEl) storyTitleEl.innerText = "Lỗi: không có tên truyện.";
        if (chapListEl) chapListEl.innerText = "Lỗi: không có tên truyện.";
        return;
    }

    if (storyTitleEl) {
        storyTitleEl.innerText = story;
    }

    // Encode story name for URL
    const encodedStory = encodeURIComponent(story);
    const apiUrl = `https://api.github.com/repos/huynoobz0/HuynoobzTranslatedComics/contents/${encodedStory}`;

    try {
        const data = await cachedFetch(apiUrl);

        if (!Array.isArray(data)) {
            if (chapListEl) chapListEl.innerText = `Không thể tải cây thư mục. Dữ liệu nhận được: ${JSON.stringify(data)}`;
            return;
        }

        // Show files at root level if any
        const rootFiles = data.filter(item => item.type === "file").sort(numericSort);
        const folders = data.filter(item => item.type === "dir").sort((a, b) => a.name.localeCompare(b.name));

        let html = "";
        
        // Display root level files
        for (const file of rootFiles) {
            const fileUrl = `https://raw.githubusercontent.com/huynoobz0/HuynoobzTranslatedComics/refs/heads/main/${encodedStory}/${encodeURIComponent(file.name)}`;
            const escapedUrl = fileUrl.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const escapedName = file.name.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            html += `<div class="chap"><a href="#" onclick="loadHtmlFile('${escapedUrl}', '${escapedName}'); return false;">${file.name}</a></div>`;
        }

        // Recursively load all folders
        for (const folder of folders) {
            const folderId = folder.name.replace(/\//g, '_');
            html += `<div class="folder">
                        <div class="folder-title">${folder.name}</div>
                        <div id="f-${folderId}">Đang tải...</div>
                     </div>`;
        }

        if (chapListEl) {
            chapListEl.innerHTML = html;
        }
        
        // Load folders after DOM is updated
        for (const folder of folders) {
            const folderId = folder.name.replace(/\//g, '_');
            loadFolderRecursive(story, folder.name, folderId);
        }

    } catch (e) {
        // Better error message for CORS issues
        if (e.name === 'TypeError' && e.message.includes('fetch')) {
            if (chapListEl) chapListEl.innerText = "Lỗi CORS: Không thể kết nối tới GitHub API. Vui lòng chạy từ web server (không dùng file:///).";
        } else {
            if (chapListEl) chapListEl.innerText = `Lỗi kết nối GitHub: ${e.message}`;
        }
        console.error("Error loading chapters:", e);
    }
};

async function loadFolderRecursive(storyName, folderPath, folderId) {
    const encodedStory = encodeURIComponent(storyName);
    const encodedFolder = encodeURIComponent(folderPath);
    const apiUrl = `https://api.github.com/repos/huynoobz0/HuynoobzTranslatedComics/contents/${encodedStory}/${encodedFolder}`;
    const folderDiv = document.getElementById(`f-${folderId}`);

    console.log("loadFolderRecursive:", { storyName, folderPath, folderId, apiUrl, folderDiv: !!folderDiv });

    if (!folderDiv) {
        console.error("Folder div not found:", `f-${folderId}`);
        return;
    }

    try {
        const data = await cachedFetch(apiUrl);
        
        console.log("Folder data received:", { folderPath, dataLength: Array.isArray(data) ? data.length : 'not array', data });

        if (!Array.isArray(data)) {
            folderDiv.innerText = "Không thể tải danh sách.";
            return;
        }

        // Separate files and folders
        const files = data.filter(item => item.type === "file").sort(numericSort);
        const subFolders = data.filter(item => item.type === "dir").sort((a, b) => a.name.localeCompare(b.name));
        
        console.log("Files:", files.length, "Subfolders:", subFolders.length);

        let html = "";
        
        // Display files in current folder
        for (const file of files) {
            const fileUrl = `https://raw.githubusercontent.com/huynoobz0/HuynoobzTranslatedComics/refs/heads/main/${encodedStory}/${encodedFolder}/${encodeURIComponent(file.name)}`;
            const escapedUrl = fileUrl.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const escapedName = file.name.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            html += `<div class="chap"><a href="#" onclick="loadHtmlFile('${escapedUrl}', '${escapedName}'); return false;">${file.name}</a></div>`;
        }

        // Add subfolders to HTML first
        const subFolderData = [];
        for (const subFolder of subFolders) {
            const subFolderPath = folderPath ? `${folderPath}/${subFolder.name}` : subFolder.name;
            const subFolderId = subFolderPath.replace(/\//g, '_');
            html += `<div class="folder">
                        <div class="folder-title">${subFolder.name}</div>
                        <div id="f-${subFolderId}">Đang tải...</div>
                     </div>`;
            subFolderData.push({ path: subFolderPath, id: subFolderId });
        }

        // Set HTML first so DOM elements exist
        if (html === "" && files.length === 0 && subFolders.length === 0) {
            folderDiv.innerText = "Thư mục trống.";
        } else {
            folderDiv.innerHTML = html;
        }
        
        // Now recursively load subfolders after DOM is updated
        for (const subFolder of subFolderData) {
            loadFolderRecursive(storyName, subFolder.path, subFolder.id);
        }

    } catch (e) {
        if (error.name === 'TypeError' && error.message.includes('fetch')) {
            folderDiv.innerText = "Lỗi CORS";
        } else if (error.status) {
            folderDiv.innerText = `Lỗi HTTP ${error.status}`;
        } else if (error.message) {
            folderDiv.innerText = `Lỗi: ${error.message}`;
        } else {
            folderDiv.innerText = `Lỗi: ${error}`;
        }
        console.error("Error loading folder:", error);
    }
}

// Store chapter list HTML for restoration
let savedChapListHtml = null;

// Width adjustment for chapter viewing
let currentMaxWidth = parseInt(localStorage.getItem('chapterMaxWidth')) || 800;
const minWidth = 400;
const maxWidth = 2000;
const widthStep = 50;
let isViewingChapter = false;

// Initialize width controls
function initWidthControls() {
    const widthControls = document.getElementById("width-controls");
    const widthDisplay = document.getElementById("width-display");
    const widthDecrease = document.getElementById("width-decrease");
    const widthIncrease = document.getElementById("width-increase");
    const contentDiv = document.getElementById("content");
    
    if (!widthControls || !widthDisplay || !widthDecrease || !widthIncrease) return;
    
    // Update display
    function updateWidthDisplay() {
        widthDisplay.textContent = currentMaxWidth + "px";
        if (contentDiv && isViewingChapter) {
            contentDiv.style.maxWidth = currentMaxWidth + "px";
        }
        localStorage.setItem('chapterMaxWidth', currentMaxWidth);
    }
    
    // Decrease width
    widthDecrease.addEventListener("click", () => {
        if (currentMaxWidth > minWidth) {
            currentMaxWidth = Math.max(minWidth, currentMaxWidth - widthStep);
            updateWidthDisplay();
        }
    });
    
    // Increase width
    widthIncrease.addEventListener("click", () => {
        if (currentMaxWidth < maxWidth) {
            currentMaxWidth = Math.min(maxWidth, currentMaxWidth + widthStep);
            updateWidthDisplay();
        }
    });
    
    // Initial display update (don't set max-width, just show the value)
    widthDisplay.textContent = currentMaxWidth + "px";
}

// Show/hide width controls
function showWidthControls(show) {
    const widthControls = document.getElementById("width-controls");
    const contentDiv = document.getElementById("content");
    
    isViewingChapter = show;
    
    if (widthControls) {
        widthControls.style.display = show ? "flex" : "none";
    }
    
    if (contentDiv) {
        if (show) {
            contentDiv.classList.add("viewing-chapter");
            contentDiv.style.maxWidth = currentMaxWidth + "px";
        } else {
            contentDiv.classList.remove("viewing-chapter");
            contentDiv.style.maxWidth = "auto";
        }
    }
}

// Load HTML file content
async function loadHtmlFile(fileUrl, fileName) {
    const contentDiv = document.getElementById("content");
    const backHomeBtn = document.getElementById("back-home-btn");
    const backChapListBtn = document.getElementById("back-chaplist-btn");
    
    // Save current chapter list HTML if viewing chapter list
    if (contentDiv && contentDiv.querySelector("#chap-list")) {
        savedChapListHtml = contentDiv.innerHTML;
    }
    
    try {
        // Show loading
        contentDiv.innerHTML = `<div style="padding: 20px; text-align: center;">Đang tải ${fileName}...</div>`;
        
        // Fetch HTML file
        const res = await fetch(fileUrl);
        if (!res.ok) {
            contentDiv.innerHTML = `<div style="padding: 20px;">Lỗi tải file: HTTP ${res.status}</div>`;
            return;
        }
        
        const html = await res.text();
        
        // Load the HTML content
        contentDiv.innerHTML = html;
        
        // Show back buttons and width controls
        if (backHomeBtn) backHomeBtn.style.display = "inline-block";
        if (backChapListBtn) backChapListBtn.style.display = "inline-block";
        showWidthControls(true);
        
    } catch (e) {
        contentDiv.innerHTML = `<div style="padding: 20px;">Lỗi: ${e.message}</div>`;
        console.error("Error loading HTML file:", e);
    }
}

// Back to chapter list handler
function backToChapList() {
    const contentDiv = document.getElementById("content");
    const backChapListBtn = document.getElementById("back-chaplist-btn");
    
    if (savedChapListHtml) {
        contentDiv.innerHTML = savedChapListHtml;
        if (backChapListBtn) backChapListBtn.style.display = "none";
        showWidthControls(false);
    } else {
        // If no saved HTML, reload the chapter list page
        const params = new URLSearchParams(location.search);
        const story = params.get("story");
        if (story) {
            loadPage("chapList").then(() => {
                setTimeout(() => {
                    loadChapters(decodeURIComponent(story));
                }, 100);
            });
        }
    }
}

// Initialize width controls when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initWidthControls);
} else {
    initWidthControls();
}

// Remove third-party injected div
function removeThirdPartyDiv() {
    // Find div with the specific styling pattern
    const allDivs = document.querySelectorAll('div');
    for (const div of allDivs) {
        const style = div.getAttribute('style');
        if (style && 
            style.includes('position: fixed') && 
            style.includes('bottom: 0%') && 
            style.includes('left: 0%') && 
            style.includes('right: 0%') && 
            style.includes('width: 100%') && 
            style.includes('height: 55px') && 
            style.includes('z-index: 9999')) {
            console.log("Removing third-party div");
            div.remove();
            return true;
        }
    }
    return false;
}

// Use MutationObserver to watch for DOM changes
const observer = new MutationObserver((mutations) => {
    removeThirdPartyDiv();
});

// Start observing
observer.observe(document.body, {
    childList: true,
    subtree: true
});

// Also check immediately and periodically as backup
removeThirdPartyDiv();
setInterval(removeThirdPartyDiv, 1000);

// Back button handlers
const backHomeBtn = document.getElementById("back-home-btn");
if (backHomeBtn) {
    backHomeBtn.addEventListener("click", () => {
        showWidthControls(false);
        location.href = "?p=home";
    });
}

const backChapListBtn = document.getElementById("back-chaplist-btn");
if (backChapListBtn) {
    backChapListBtn.addEventListener("click", backToChapList);
}

// Get latest chapter number from a story directory
// Recursively searches all files and finds the highest chapter number
// Chapter files should be named like: 1.0.html, 1.5.html, 2.0.html, etc.
async function getLatestChap(storyDir) {
    if (!storyDir) return null;
    
    try {
        const encodedDir = encodeURIComponent(storyDir);
        const apiUrl = `https://api.github.com/repos/huynoobz0/HuynoobzTranslatedComics/contents/${encodedDir}`;
        
        const data = await cachedFetch(apiUrl);
        if (!Array.isArray(data)) {
            return null;
        }
        
        let maxChap = null;
        
        // Recursively process all items
        for (const item of data) {
            if (item.type === "file") {
                // Check if file matches pattern: <float>.html
                const match = item.name.match(/^(\d+\.?\d*)\.html$/);
                if (match) {
                    const chapNum = parseFloat(match[1]);
                    if (maxChap === null || chapNum > maxChap) {
                        maxChap = chapNum;
                    }
                }
            } else if (item.type === "dir") {
                // Recursively search subdirectories
                const subDir = storyDir ? `${storyDir}/${item.name}` : item.name;
                const subMaxChap = await getLatestChap(subDir);
                if (subMaxChap !== null && (maxChap === null || subMaxChap > maxChap)) {
                    maxChap = subMaxChap;
                }
            }
        }
        
        return maxChap;
    } catch (e) {
        console.error("Error in getLatestChap:", e);
        return null;
    }
}

// Update latest chapter for all stories when home page loads
async function updateLatestChapters() {
    const latestChapterDivs = document.querySelectorAll(".latest-chapter");
    
    for (const div of latestChapterDivs) {
        const storyDir = div.getAttribute("data-story-dir");
        if (storyDir) {
            const latestChap = await getLatestChap(storyDir);
            const boldEl = div.querySelector("b");
            if (boldEl) {
                if (latestChap !== null) {
                    boldEl.textContent = latestChap.toString();
                } else {
                    boldEl.textContent = "—";
                }
            }
        }
    }
}


</script>

</body>
</html>
